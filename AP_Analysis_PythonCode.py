#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AP Audit (LLDP-based) - v16
Author: (generated by ChatGPT)
Python >=3.9

功能/口徑：
1) 以 AC 的 `display wlan ap all` 為全集（權威 AP 名單），含 AC 歸屬；
2) 以 LLDP neighbor-information 作為“在線”與“速率（100M/1000M）”的唯一來源；
3) 以 `display interface brief` 僅用於統計「介面描述含 AP 且 LINK=DOWN」；
4) 匯出多個 sheet 的 Excel 報表：
   - 統計摘要（LLDP口徑）
   - 在線 AP（含 AC、交換機檔、接口、速率、AC log、LLDP 原始段落）
   - 在線 AP_100M（LLDP）
   - 在線 AP_1000M（LLDP）
   - Offline AP（AC有、LLDP無）
   - 遺留AP（描述含AP且DOWN）

用法：
    python ap_audit_lldp_v16.py \
        --ac-logs /path/to/ac_logs_dir \
        --lldp-logs /path/to/switch_logs_dir [/path/to/another_switch_logs_dir ...] \
        --out /path/to/output.xlsx

依賴：
    pip install pandas xlsxwriter

輸入假設：
- AC 日誌：包含 `<espac0X.***>` 的 CLI 輸出，且 `display wlan ap all` 區塊中每行第一欄是 AP 名稱，形如 `xxx_apN`；
- 交換機日誌：包含 `LLDP neighbor-information of port` 區塊；OperMau 形如 `OperMau : speed(1000)/duplex(Full)`；
- `display interface brief` 行形如：
  `GE1/0/2   UP   1G(a)   F(a)   A   1322   <desc...>`
"""

import re
import sys
import argparse
from pathlib import Path
import pandas as pd

AP_RE = re.compile(r'([A-Za-z0-9_-]+_ap\d+)\b', re.IGNORECASE)
IFACE_ROW_RE = re.compile(
    r'^(?P<iface>(?:GE|GigabitEthernet|XGE|Ten-GigabitEthernet|FortyGigE|Eth-Trunk|Bridge-Aggregation)\S*)\s+'
    r'(?P<link>UP|DOWN)\s+'
    r'(?P<speed>[A-Za-z0-9\(\)\/]+)\s+'
    r'(?P<duplex>[A-Za-z\(\)\/]+)\s+'
    r'(?P<type>[A-Za-z-]+)\s+'
    r'(?P<pvid>\d+)\s*(?P<desc>.*)$'
)

def read_text(path: Path) -> str:
    try:
        return path.read_text(errors="ignore")
    except Exception:
        return ""

def extract_ac_ap_list(path: Path):
    """從 AC 日誌抓取 AP 名稱清單（以 AC 作為權威全集）"""
    text = read_text(path)
    ap_names = []
    for line in text.splitlines():
        m = AP_RE.match(line.strip())
        if m:
            ap_names.append(m.group(1))
    # 去重保序
    seen = set(); out = []
    for n in ap_names:
        if n not in seen:
            seen.add(n); out.append(n)
    return out

def extract_lldp_blocks(text: str):
    blocks, cur = [], []
    for line in text.splitlines():
        if re.search(r'LLDP neighbor-information of port', line, re.IGNORECASE):
            if cur: blocks.append("\n".join(cur)); cur = []
        if re.search(r'LLDP neighbor-information', line, re.IGNORECASE):
            cur.append(line)
        elif cur:
            cur.append(line)
    if cur:
        blocks.append("\n".join(cur))
    return blocks

def parse_lldp_block(block: str):
    # 介面
    local_if = ""
    m_if = re.search(r'\[(.+?)\]', block)
    if m_if:
        local_if = m_if.group(1).strip()
    # AP 名稱（System name）
    m_sys = re.search(r'System name\s*:\s*(.+)', block)
    sysname = (m_sys.group(1).strip() if m_sys else "")
    if not sysname:
        # Fallback: Port description
        m_pd = re.search(r'Port description\s*:\s*(.+)', block)
        if m_pd:
            sysname = m_pd.group(1).strip()
    # 速率（僅 LLDP）
    m_speed = re.search(r'OperMau\s*:\s*speed\((\d+)\)', block, re.IGNORECASE)
    lldp_speed = ""
    if m_speed:
        v = m_speed.group(1)
        if v == "1000":
            lldp_speed = "1G"
        elif v == "100":
            lldp_speed = "100M"
    return local_if, sysname, lldp_speed, block

def parse_lldp_folder(folder: Path) -> pd.DataFrame:
    recs = []
    for f in folder.rglob("*.log"):
        text = read_text(f)
        for blk in extract_lldp_blocks(text):
            local_if, sysname, lldp_speed, block = parse_lldp_block(blk)
            if not sysname:
                continue
            if not AP_RE.search(sysname):
                continue
            recs.append({
                "switch_log": f.name,
                "interface": local_if,
                "ap_name": sysname,
                "lldp_speed": lldp_speed,
                "lldp_block": block
            })
    return pd.DataFrame(recs)

def parse_interface_folder(folder: Path) -> pd.DataFrame:
    rows = []
    for f in folder.rglob("*.log"):
        text = read_text(f)
        for line in text.splitlines():
            m = IFACE_ROW_RE.match(line.strip())
            if m:
                d = m.groupdict()
                d["switch_log"] = f.name
                rows.append(d)
    return pd.DataFrame(rows)

def build_report(ac_logs_dir: Path, lldp_dirs: list[Path], out_path: Path):
    # 1) 讀 AC 權威 AP 清單 + AC 名稱
    ac_map = {}
    ac_rows = []
    for p in ac_logs_dir.rglob("*.log"):
        # 由檔名猜 AC 名稱（如 2025-10-08_10-15-51.log -> 不可靠）；建議從提示符 <espac0X> 取，但此處只需來源log；
        # 若需嚴格 AC 名稱，可在檔名或內容中查找 <espac..> 再解析。
        ac_name = None
        txt = read_text(p)
        mhost = re.search(r'<([^>]+)>', txt)
        if mhost:
            ac_name = mhost.group(1).split('.')[0]
        else:
            ac_name = p.stem  # fallback

        for ap in extract_ac_ap_list(p):
            ac_rows.append({"ap_name": ap, "AC控制器": ac_name, "AC_log": p.name})
            ac_map[ap] = ac_name
    df_ac = pd.DataFrame(ac_rows).drop_duplicates(subset=["ap_name"])
    if df_ac.empty:
        raise SystemExit("未在 AC 日誌中解析到任何 AP，請確認 AC 日誌目錄或格式。")

    # 2) 讀取所有 LLDP 來源資料夾
    lldp_frames = []
    for d in lldp_dirs:
        if d.exists():
            lldp_frames.append(parse_lldp_folder(d))
    df_lldp = pd.concat(lldp_frames, ignore_index=True) if lldp_frames else pd.DataFrame(columns=["switch_log","interface","ap_name","lldp_speed","lldp_block"])

    # 2.1) 以 AP 合併 LLDP（若同一 AP 在多個交換機出現，優先取有速率的；1G > 100M）
    def consolidate_ap(group: pd.DataFrame):
        speeds = set([s for s in group["lldp_speed"].tolist() if s])
        if "1G" in speeds:
            speed = "1G"
        elif "100M" in speeds:
            speed = "100M"
        else:
            speed = ""
        good = group[group["lldp_speed"]==speed] if speed else group
        row = good.iloc[0]
        return pd.Series({
            "switch_log": row["switch_log"],
            "interface": row["interface"],
            "uplink_speed": speed,
            "lldp_block": row["lldp_block"]
        })
    df_lldp_by_ap = df_lldp.groupby("ap_name").apply(consolidate_ap).reset_index() if not df_lldp.empty else pd.DataFrame(columns=["ap_name","switch_log","interface","uplink_speed","lldp_block"])

    # 3) ONLINE（LLDP出現）與 OFFLINE（AC有但LLDP無）
    df_online = df_ac.merge(df_lldp_by_ap, on="ap_name", how="inner")
    df_offline = df_ac[~df_ac["ap_name"].isin(df_online["ap_name"])].copy()

    # 4) 介面描述僅用於「描述含 AP 且 LINK=DOWN」
    iface_frames = []
    for d in lldp_dirs:
        if d.exists():
            iface_frames.append(parse_interface_folder(d))
    df_iface = pd.concat(iface_frames, ignore_index=True) if iface_frames else pd.DataFrame(columns=["iface","link","speed","duplex","type","pvid","desc","switch_log"])
    df_legacy_down = df_iface[(df_iface["desc"].str.contains(r'ap', case=False, na=False)) & (df_iface["link"].str.upper()=="DOWN")].copy()

    # 5) 速率分組（LLDP only）
    df_online_100m = df_online[df_online["uplink_speed"]=="100M"].copy()
    df_online_1g   = df_online[df_online["uplink_speed"]=="1G"].copy()

    # 6) 摘要與校驗
    summary = pd.DataFrame({
        "項目": [
            "AC清單AP總數（含不在線）",
            "在線AP（LLDP出現）",
            "在線AP中的100M（LLDP）",
            "在線AP中的1000M（LLDP）",
            "Offline AP（AC有、LLDP無）",
            "校驗：在線 = 1000M + 100M"
        ],
        "數值": [
            len(df_ac),
            len(df_online),
            len(df_online_100m),
            len(df_online_1g),
            len(df_offline),
            "✅" if (len(df_online) == (len(df_online_1g) + len(df_online_100m))) else f"❌（{len(df_online)} ≠ {len[df_online_1g]}+{len[df_online_100m]}）"
        ]
    })

    # 7) 欄位選擇與排序
    online_cols = ["ap_name","AC控制器","switch_log","interface","uplink_speed","AC_log","lldp_block"]
    offline_cols = ["ap_name","AC控制器","AC_log"]
    legacy_cols = ["switch_log","iface","link","speed","pvid","desc"]

    df_online_out = df_online[online_cols].sort_values(["AC控制器","ap_name"]).reset_index(drop=True)
    df_offline_out = df_offline[offline_cols].sort_values(["AC控制器","ap_name"]).reset_index(drop=True)
    df_legacy_out = df_legacy_down[legacy_cols].sort_values(["switch_log","iface"]).reset_index(drop=True)

    # 8) 匯出 Excel
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with pd.ExcelWriter(out_path, engine="xlsxwriter") as writer:
        summary.to_excel(writer, index=False, sheet_name="統計摘要_LLDP口徑")
        df_online_out.to_excel(writer, index=False, sheet_name="在線AP_LLDP")
        df_online_100m[online_cols].to_excel(writer, index=False, sheet_name="在線AP_100M_LLDP")
        df_online_1g[online_cols].to_excel(writer, index=False, sheet_name="在線AP_1000M_LLDP")
        df_offline_out.to_excel(writer, index=False, sheet_name="Offline_AP(AC有LLDP無)")
        df_legacy_out.to_excel(writer, index=False, sheet_name="遺留AP_描述含AP但DOWN")

    print("輸出完成：", out_path)

def main():
    parser = argparse.ArgumentParser(description="AP Audit via LLDP (v16口徑)")
    parser.add_argument("--ac-logs", type=str, required=True, help="AC 日誌所在資料夾（包含四台 AC 的 log）")
    parser.add_argument("--lldp-logs", type=str, nargs="+", required=True, help="一個或多個交換機日誌資料夾（掃描 LLDP 與 interface brief）")
    parser.add_argument("--out", type=str, required=True, help="輸出的 Excel 檔名，例如 /tmp/AP_Statistics_v16_LLDP.xlsx")
    args = parser.parse_args()

    ac_dir = Path(args.ac_logs)
    if not ac_dir.exists():
        print("AC 日誌目錄不存在：", ac_dir)
        sys.exit(1)

    lldp_dirs = [Path(p) for p in args.lldp_logs]
    for d in lldp_dirs:
        if not d.exists():
            print("警告：交換機日誌目錄不存在：", d)

    out_path = Path(args.out)
    build_report(ac_dir, lldp_dirs, out_path)

if __name__ == "__main__":
    main()
